// This is a JavaScript coding problem from BFE.dev 

/**
 * @param {any[]} arr
 * @returns {void}
 */
function shuffle(arr) {
  // modify the arr inline to change the order randomly
  // for (let i = 0; i < arr.length; i++) {
  //   const j = i + Math.floor(Math.random() * (arr.length - i));
  //   [arr[i], arr[j]] = [arr[j], arr[i]]
  // }
  // or
  for (let i = arr.length - 1; i >= 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]]
  }
}

/*
[1, 2, 3]

3 ** 3 = 27

1. i = 0, j = 0: [1, 2, 3]
2. i = 0, j = 1: [2, 1, 3]
3. i = 0, j = 2: [3, 2, 1]

----------

1. i = 0, j = 0: [1, 2, 3]

1.1. i = 1, j = 0: [2, 1, 3]
1.2. i = 1, j = 1: [1, 2, 3]
1.3. i = 1, j = 2: [1, 3, 2]


1.1. i = 1, j = 0: [2, 1, 3]

1.1.1 i = 2, j = 0: [3, 1, 2] -
1.1.2 i = 2, j = 1: [2, 3, 1] -
1.1.3 i = 2, j = 2: [2, 1, 3] -

1.2. i = 1, j = 1: [1, 2, 3]

1.2.1 i = 2, j = 0: [3, 2, 1] -
1.2.2 i = 2, j = 1: [1, 3, 2] -
1.2.3 i = 2, j = 2: [1, 2, 3] -

1.3. i = 1, j = 2: [1, 3, 2]

1.3.1 i = 2, j = 0: [2, 3, 1] -
1.3.2 i = 2, j = 1: [1, 2, 3] -
1.3.3 i = 2, j = 2: [1, 3, 2] -

----------

2. i = 0, j = 1: [2, 1, 3]

2.1. i = 1, j = 0: [1, 2, 3]
2.2. i = 1, j = 1: [2, 1, 3]
2.3. i = 1, j = 2: [2, 3, 1]


2.1. i = 1, j = 0: [1, 2, 3]

2.1.1 i = 2, j = 0: [3, 2, 1] -
2.1.2 i = 2, j = 1: [1, 3, 2] -
2.1.3 i = 2, j = 2: [1, 2, 3] -

2.2. i = 1, j = 1: [2, 1, 3]

2.2.1 i = 2, j = 0: [3, 1, 2] -
2.2.2 i = 2, j = 1: [2, 3, 1] -
2.2.3 i = 2, j = 2: [2, 1, 3] -

2.3. i = 1, j = 2: [2, 3, 1]

2.3.1 i = 2, j = 0: [1, 3, 2] -
2.3.2 i = 2, j = 1: [2, 1, 3] -
2.3.3 i = 2, j = 2: [2, 3, 1] -

----------

3. i = 0, j = 2: [3, 2, 1]

3.1. i = 1, j = 0: [2, 3, 1]
3.2. i = 1, j = 1: [3, 2, 1]
3.3. i = 1, j = 2: [3, 1, 2]


3.1. i = 1, j = 0: [2, 3, 1]

3.1.1 i = 2, j = 0: [1, 3, 2] -
3.1.2 i = 2, j = 1: [2, 1, 3] -
3.1.3 i = 2, j = 2: [2, 3, 1] -

3.2. i = 1, j = 1: [3, 2, 1]

3.2.1 i = 2, j = 0: [1, 2, 3] -
3.2.2 i = 2, j = 1: [3, 1, 2] -
3.2.3 i = 2, j = 2: [3, 2, 1] -

3.3. i = 1, j = 2: [3, 1, 2]

3.3.1 i = 2, j = 0: [2, 1, 3] -
3.3.2 i = 2, j = 1: [3, 2, 1] -
3.3.3 i = 2, j = 2: [3, 1, 2] -


[3, 1, 2]: 4 次
[2, 3, 1]: 5 次
[2, 1, 3]: 5 次
[3, 2, 1]: 4 次
[1, 3, 2]: 5 次
[1, 2, 3]: 4 次

数学视角：排列的生成路径数量
对于长度为3的数组，正确算法（Fisher-Yates）的每个排列有且仅有 3! = 6种路径，每种路径概率相等（1/6）。但原算法的路径数量与排列无关，而是由交换的随机性决定，导致：

某些排列的生成路径更多：例如 [1,3,2] 有5条路径，而 [1,2,3] 只有4条。

路径数量不均衡：总路径数为27，无法被6整除（27 ÷ 6 = 4.5），因此某些排列必然出现更多次。


 */

